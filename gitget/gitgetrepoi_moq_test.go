// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package gitget

import (
	"bytes"
	"os"
	"os/exec"
	"sync"
)

var (
	lockGitGetRepoIMockClone                           sync.RWMutex
	lockGitGetRepoIMockCreateSymlink                   sync.RWMutex
	lockGitGetRepoIMockEnsurePathExists                sync.RWMutex
	lockGitGetRepoIMockExecGitCommand                  sync.RWMutex
	lockGitGetRepoIMockGetCurrentBranch                sync.RWMutex
	lockGitGetRepoIMockGetRepoLocalName                sync.RWMutex
	lockGitGetRepoIMockGitCheckout                     sync.RWMutex
	lockGitGetRepoIMockGitPull                         sync.RWMutex
	lockGitGetRepoIMockGitStashPop                     sync.RWMutex
	lockGitGetRepoIMockGitStashSave                    sync.RWMutex
	lockGitGetRepoIMockIsClean                         sync.RWMutex
	lockGitGetRepoIMockIsCurrentBranchRef              sync.RWMutex
	lockGitGetRepoIMockPathExists                      sync.RWMutex
	lockGitGetRepoIMockPrepare                         sync.RWMutex
	lockGitGetRepoIMockProcessRepoBasedOnCleaness      sync.RWMutex
	lockGitGetRepoIMockProcessRepoBasedOnCurrentBranch sync.RWMutex
	lockGitGetRepoIMockProcessSymlinks                 sync.RWMutex
	lockGitGetRepoIMockRepoPathExists                  sync.RWMutex
	lockGitGetRepoIMockSetDefaultRef                   sync.RWMutex
	lockGitGetRepoIMockSetRepoFullPath                 sync.RWMutex
	lockGitGetRepoIMockSetRepoLocalName                sync.RWMutex
	lockGitGetRepoIMockSetSha                          sync.RWMutex
)

// Ensure, that GitGetRepoIMock does implement GitGetRepoI.
// If this is not the case, regenerate this file with moq.
var _ GitGetRepoI = &GitGetRepoIMock{}

// GitGetRepoIMock is a mock implementation of GitGetRepoI.
//
//     func TestSomethingThatUsesGitGetRepoI(t *testing.T) {
//
//         // make and configure a mocked GitGetRepoI
//         mockedGitGetRepoI := &GitGetRepoIMock{
//             CloneFunc: func() bool {
// 	               panic("mock out the Clone method")
//             },
//             CreateSymlinkFunc: func(symlink string)  {
// 	               panic("mock out the CreateSymlink method")
//             },
//             EnsurePathExistsFunc: func()  {
// 	               panic("mock out the EnsurePathExists method")
//             },
//             ExecGitCommandFunc: func(args []string, stdoutb *bytes.Buffer, erroutb *bytes.Buffer, dir string) (*exec.Cmd, error) {
// 	               panic("mock out the ExecGitCommand method")
//             },
//             GetCurrentBranchFunc: func() string {
// 	               panic("mock out the GetCurrentBranch method")
//             },
//             GetRepoLocalNameFunc: func() string {
// 	               panic("mock out the GetRepoLocalName method")
//             },
//             GitCheckoutFunc: func(branch string)  {
// 	               panic("mock out the GitCheckout method")
//             },
//             GitPullFunc: func()  {
// 	               panic("mock out the GitPull method")
//             },
//             GitStashPopFunc: func()  {
// 	               panic("mock out the GitStashPop method")
//             },
//             GitStashSaveFunc: func()  {
// 	               panic("mock out the GitStashSave method")
//             },
//             IsCleanFunc: func() bool {
// 	               panic("mock out the IsClean method")
//             },
//             IsCurrentBranchRefFunc: func() bool {
// 	               panic("mock out the IsCurrentBranchRef method")
//             },
//             PathExistsFunc: func(path string) (bool, os.FileInfo) {
// 	               panic("mock out the PathExists method")
//             },
//             PrepareFunc: func()  {
// 	               panic("mock out the Prepare method")
//             },
//             ProcessRepoBasedOnCleanessFunc: func()  {
// 	               panic("mock out the ProcessRepoBasedOnCleaness method")
//             },
//             ProcessRepoBasedOnCurrentBranchFunc: func()  {
// 	               panic("mock out the ProcessRepoBasedOnCurrentBranch method")
//             },
//             ProcessSymlinksFunc: func()  {
// 	               panic("mock out the ProcessSymlinks method")
//             },
//             RepoPathExistsFunc: func() bool {
// 	               panic("mock out the RepoPathExists method")
//             },
//             SetDefaultRefFunc: func()  {
// 	               panic("mock out the SetDefaultRef method")
//             },
//             SetRepoFullPathFunc: func()  {
// 	               panic("mock out the SetRepoFullPath method")
//             },
//             SetRepoLocalNameFunc: func()  {
// 	               panic("mock out the SetRepoLocalName method")
//             },
//             SetShaFunc: func()  {
// 	               panic("mock out the SetSha method")
//             },
//         }
//
//         // use mockedGitGetRepoI in code that requires GitGetRepoI
//         // and then make assertions.
//
//     }
type GitGetRepoIMock struct {
	// CloneFunc mocks the Clone method.
	CloneFunc func() bool

	// CreateSymlinkFunc mocks the CreateSymlink method.
	CreateSymlinkFunc func(symlink string)

	// EnsurePathExistsFunc mocks the EnsurePathExists method.
	EnsurePathExistsFunc func()

	// ExecGitCommandFunc mocks the ExecGitCommand method.
	ExecGitCommandFunc func(args []string, stdoutb *bytes.Buffer, erroutb *bytes.Buffer, dir string) (*exec.Cmd, error)

	// GetCurrentBranchFunc mocks the GetCurrentBranch method.
	GetCurrentBranchFunc func() string

	// GetRepoLocalNameFunc mocks the GetRepoLocalName method.
	GetRepoLocalNameFunc func() string

	// GitCheckoutFunc mocks the GitCheckout method.
	GitCheckoutFunc func(branch string)

	// GitPullFunc mocks the GitPull method.
	GitPullFunc func()

	// GitStashPopFunc mocks the GitStashPop method.
	GitStashPopFunc func()

	// GitStashSaveFunc mocks the GitStashSave method.
	GitStashSaveFunc func()

	// IsCleanFunc mocks the IsClean method.
	IsCleanFunc func() bool

	// IsCurrentBranchRefFunc mocks the IsCurrentBranchRef method.
	IsCurrentBranchRefFunc func() bool

	// PathExistsFunc mocks the PathExists method.
	PathExistsFunc func(path string) (bool, os.FileInfo)

	// PrepareFunc mocks the Prepare method.
	PrepareFunc func()

	// ProcessRepoBasedOnCleanessFunc mocks the ProcessRepoBasedOnCleaness method.
	ProcessRepoBasedOnCleanessFunc func()

	// ProcessRepoBasedOnCurrentBranchFunc mocks the ProcessRepoBasedOnCurrentBranch method.
	ProcessRepoBasedOnCurrentBranchFunc func()

	// ProcessSymlinksFunc mocks the ProcessSymlinks method.
	ProcessSymlinksFunc func()

	// RepoPathExistsFunc mocks the RepoPathExists method.
	RepoPathExistsFunc func() bool

	// SetDefaultRefFunc mocks the SetDefaultRef method.
	SetDefaultRefFunc func()

	// SetRepoFullPathFunc mocks the SetRepoFullPath method.
	SetRepoFullPathFunc func()

	// SetRepoLocalNameFunc mocks the SetRepoLocalName method.
	SetRepoLocalNameFunc func()

	// SetShaFunc mocks the SetSha method.
	SetShaFunc func()

	// calls tracks calls to the methods.
	calls struct {
		// Clone holds details about calls to the Clone method.
		Clone []struct {
		}
		// CreateSymlink holds details about calls to the CreateSymlink method.
		CreateSymlink []struct {
			// Symlink is the symlink argument value.
			Symlink string
		}
		// EnsurePathExists holds details about calls to the EnsurePathExists method.
		EnsurePathExists []struct {
		}
		// ExecGitCommand holds details about calls to the ExecGitCommand method.
		ExecGitCommand []struct {
			// Args is the args argument value.
			Args []string
			// Stdoutb is the stdoutb argument value.
			Stdoutb *bytes.Buffer
			// Erroutb is the erroutb argument value.
			Erroutb *bytes.Buffer
			// Dir is the dir argument value.
			Dir string
		}
		// GetCurrentBranch holds details about calls to the GetCurrentBranch method.
		GetCurrentBranch []struct {
		}
		// GetRepoLocalName holds details about calls to the GetRepoLocalName method.
		GetRepoLocalName []struct {
		}
		// GitCheckout holds details about calls to the GitCheckout method.
		GitCheckout []struct {
			// Branch is the branch argument value.
			Branch string
		}
		// GitPull holds details about calls to the GitPull method.
		GitPull []struct {
		}
		// GitStashPop holds details about calls to the GitStashPop method.
		GitStashPop []struct {
		}
		// GitStashSave holds details about calls to the GitStashSave method.
		GitStashSave []struct {
		}
		// IsClean holds details about calls to the IsClean method.
		IsClean []struct {
		}
		// IsCurrentBranchRef holds details about calls to the IsCurrentBranchRef method.
		IsCurrentBranchRef []struct {
		}
		// PathExists holds details about calls to the PathExists method.
		PathExists []struct {
			// Path is the path argument value.
			Path string
		}
		// Prepare holds details about calls to the Prepare method.
		Prepare []struct {
		}
		// ProcessRepoBasedOnCleaness holds details about calls to the ProcessRepoBasedOnCleaness method.
		ProcessRepoBasedOnCleaness []struct {
		}
		// ProcessRepoBasedOnCurrentBranch holds details about calls to the ProcessRepoBasedOnCurrentBranch method.
		ProcessRepoBasedOnCurrentBranch []struct {
		}
		// ProcessSymlinks holds details about calls to the ProcessSymlinks method.
		ProcessSymlinks []struct {
		}
		// RepoPathExists holds details about calls to the RepoPathExists method.
		RepoPathExists []struct {
		}
		// SetDefaultRef holds details about calls to the SetDefaultRef method.
		SetDefaultRef []struct {
		}
		// SetRepoFullPath holds details about calls to the SetRepoFullPath method.
		SetRepoFullPath []struct {
		}
		// SetRepoLocalName holds details about calls to the SetRepoLocalName method.
		SetRepoLocalName []struct {
		}
		// SetSha holds details about calls to the SetSha method.
		SetSha []struct {
		}
	}
}

// Clone calls CloneFunc.
func (mock *GitGetRepoIMock) Clone() bool {
	if mock.CloneFunc == nil {
		panic("GitGetRepoIMock.CloneFunc: method is nil but GitGetRepoI.Clone was just called")
	}
	callInfo := struct {
	}{}
	lockGitGetRepoIMockClone.Lock()
	mock.calls.Clone = append(mock.calls.Clone, callInfo)
	lockGitGetRepoIMockClone.Unlock()
	return mock.CloneFunc()
}

// CloneCalls gets all the calls that were made to Clone.
// Check the length with:
//     len(mockedGitGetRepoI.CloneCalls())
func (mock *GitGetRepoIMock) CloneCalls() []struct {
} {
	var calls []struct {
	}
	lockGitGetRepoIMockClone.RLock()
	calls = mock.calls.Clone
	lockGitGetRepoIMockClone.RUnlock()
	return calls
}

// CreateSymlink calls CreateSymlinkFunc.
func (mock *GitGetRepoIMock) CreateSymlink(symlink string) {
	if mock.CreateSymlinkFunc == nil {
		panic("GitGetRepoIMock.CreateSymlinkFunc: method is nil but GitGetRepoI.CreateSymlink was just called")
	}
	callInfo := struct {
		Symlink string
	}{
		Symlink: symlink,
	}
	lockGitGetRepoIMockCreateSymlink.Lock()
	mock.calls.CreateSymlink = append(mock.calls.CreateSymlink, callInfo)
	lockGitGetRepoIMockCreateSymlink.Unlock()
	mock.CreateSymlinkFunc(symlink)
}

// CreateSymlinkCalls gets all the calls that were made to CreateSymlink.
// Check the length with:
//     len(mockedGitGetRepoI.CreateSymlinkCalls())
func (mock *GitGetRepoIMock) CreateSymlinkCalls() []struct {
	Symlink string
} {
	var calls []struct {
		Symlink string
	}
	lockGitGetRepoIMockCreateSymlink.RLock()
	calls = mock.calls.CreateSymlink
	lockGitGetRepoIMockCreateSymlink.RUnlock()
	return calls
}

// EnsurePathExists calls EnsurePathExistsFunc.
func (mock *GitGetRepoIMock) EnsurePathExists() {
	if mock.EnsurePathExistsFunc == nil {
		panic("GitGetRepoIMock.EnsurePathExistsFunc: method is nil but GitGetRepoI.EnsurePathExists was just called")
	}
	callInfo := struct {
	}{}
	lockGitGetRepoIMockEnsurePathExists.Lock()
	mock.calls.EnsurePathExists = append(mock.calls.EnsurePathExists, callInfo)
	lockGitGetRepoIMockEnsurePathExists.Unlock()
	mock.EnsurePathExistsFunc()
}

// EnsurePathExistsCalls gets all the calls that were made to EnsurePathExists.
// Check the length with:
//     len(mockedGitGetRepoI.EnsurePathExistsCalls())
func (mock *GitGetRepoIMock) EnsurePathExistsCalls() []struct {
} {
	var calls []struct {
	}
	lockGitGetRepoIMockEnsurePathExists.RLock()
	calls = mock.calls.EnsurePathExists
	lockGitGetRepoIMockEnsurePathExists.RUnlock()
	return calls
}

// ExecGitCommand calls ExecGitCommandFunc.
func (mock *GitGetRepoIMock) ExecGitCommand(args []string, stdoutb *bytes.Buffer, erroutb *bytes.Buffer, dir string) (*exec.Cmd, error) {
	if mock.ExecGitCommandFunc == nil {
		panic("GitGetRepoIMock.ExecGitCommandFunc: method is nil but GitGetRepoI.ExecGitCommand was just called")
	}
	callInfo := struct {
		Args    []string
		Stdoutb *bytes.Buffer
		Erroutb *bytes.Buffer
		Dir     string
	}{
		Args:    args,
		Stdoutb: stdoutb,
		Erroutb: erroutb,
		Dir:     dir,
	}
	lockGitGetRepoIMockExecGitCommand.Lock()
	mock.calls.ExecGitCommand = append(mock.calls.ExecGitCommand, callInfo)
	lockGitGetRepoIMockExecGitCommand.Unlock()
	return mock.ExecGitCommandFunc(args, stdoutb, erroutb, dir)
}

// ExecGitCommandCalls gets all the calls that were made to ExecGitCommand.
// Check the length with:
//     len(mockedGitGetRepoI.ExecGitCommandCalls())
func (mock *GitGetRepoIMock) ExecGitCommandCalls() []struct {
	Args    []string
	Stdoutb *bytes.Buffer
	Erroutb *bytes.Buffer
	Dir     string
} {
	var calls []struct {
		Args    []string
		Stdoutb *bytes.Buffer
		Erroutb *bytes.Buffer
		Dir     string
	}
	lockGitGetRepoIMockExecGitCommand.RLock()
	calls = mock.calls.ExecGitCommand
	lockGitGetRepoIMockExecGitCommand.RUnlock()
	return calls
}

// GetCurrentBranch calls GetCurrentBranchFunc.
func (mock *GitGetRepoIMock) GetCurrentBranch() string {
	if mock.GetCurrentBranchFunc == nil {
		panic("GitGetRepoIMock.GetCurrentBranchFunc: method is nil but GitGetRepoI.GetCurrentBranch was just called")
	}
	callInfo := struct {
	}{}
	lockGitGetRepoIMockGetCurrentBranch.Lock()
	mock.calls.GetCurrentBranch = append(mock.calls.GetCurrentBranch, callInfo)
	lockGitGetRepoIMockGetCurrentBranch.Unlock()
	return mock.GetCurrentBranchFunc()
}

// GetCurrentBranchCalls gets all the calls that were made to GetCurrentBranch.
// Check the length with:
//     len(mockedGitGetRepoI.GetCurrentBranchCalls())
func (mock *GitGetRepoIMock) GetCurrentBranchCalls() []struct {
} {
	var calls []struct {
	}
	lockGitGetRepoIMockGetCurrentBranch.RLock()
	calls = mock.calls.GetCurrentBranch
	lockGitGetRepoIMockGetCurrentBranch.RUnlock()
	return calls
}

// GetRepoLocalName calls GetRepoLocalNameFunc.
func (mock *GitGetRepoIMock) GetRepoLocalName() string {
	if mock.GetRepoLocalNameFunc == nil {
		panic("GitGetRepoIMock.GetRepoLocalNameFunc: method is nil but GitGetRepoI.GetRepoLocalName was just called")
	}
	callInfo := struct {
	}{}
	lockGitGetRepoIMockGetRepoLocalName.Lock()
	mock.calls.GetRepoLocalName = append(mock.calls.GetRepoLocalName, callInfo)
	lockGitGetRepoIMockGetRepoLocalName.Unlock()
	return mock.GetRepoLocalNameFunc()
}

// GetRepoLocalNameCalls gets all the calls that were made to GetRepoLocalName.
// Check the length with:
//     len(mockedGitGetRepoI.GetRepoLocalNameCalls())
func (mock *GitGetRepoIMock) GetRepoLocalNameCalls() []struct {
} {
	var calls []struct {
	}
	lockGitGetRepoIMockGetRepoLocalName.RLock()
	calls = mock.calls.GetRepoLocalName
	lockGitGetRepoIMockGetRepoLocalName.RUnlock()
	return calls
}

// GitCheckout calls GitCheckoutFunc.
func (mock *GitGetRepoIMock) GitCheckout(branch string) {
	if mock.GitCheckoutFunc == nil {
		panic("GitGetRepoIMock.GitCheckoutFunc: method is nil but GitGetRepoI.GitCheckout was just called")
	}
	callInfo := struct {
		Branch string
	}{
		Branch: branch,
	}
	lockGitGetRepoIMockGitCheckout.Lock()
	mock.calls.GitCheckout = append(mock.calls.GitCheckout, callInfo)
	lockGitGetRepoIMockGitCheckout.Unlock()
	mock.GitCheckoutFunc(branch)
}

// GitCheckoutCalls gets all the calls that were made to GitCheckout.
// Check the length with:
//     len(mockedGitGetRepoI.GitCheckoutCalls())
func (mock *GitGetRepoIMock) GitCheckoutCalls() []struct {
	Branch string
} {
	var calls []struct {
		Branch string
	}
	lockGitGetRepoIMockGitCheckout.RLock()
	calls = mock.calls.GitCheckout
	lockGitGetRepoIMockGitCheckout.RUnlock()
	return calls
}

// GitPull calls GitPullFunc.
func (mock *GitGetRepoIMock) GitPull() {
	if mock.GitPullFunc == nil {
		panic("GitGetRepoIMock.GitPullFunc: method is nil but GitGetRepoI.GitPull was just called")
	}
	callInfo := struct {
	}{}
	lockGitGetRepoIMockGitPull.Lock()
	mock.calls.GitPull = append(mock.calls.GitPull, callInfo)
	lockGitGetRepoIMockGitPull.Unlock()
	mock.GitPullFunc()
}

// GitPullCalls gets all the calls that were made to GitPull.
// Check the length with:
//     len(mockedGitGetRepoI.GitPullCalls())
func (mock *GitGetRepoIMock) GitPullCalls() []struct {
} {
	var calls []struct {
	}
	lockGitGetRepoIMockGitPull.RLock()
	calls = mock.calls.GitPull
	lockGitGetRepoIMockGitPull.RUnlock()
	return calls
}

// GitStashPop calls GitStashPopFunc.
func (mock *GitGetRepoIMock) GitStashPop() {
	if mock.GitStashPopFunc == nil {
		panic("GitGetRepoIMock.GitStashPopFunc: method is nil but GitGetRepoI.GitStashPop was just called")
	}
	callInfo := struct {
	}{}
	lockGitGetRepoIMockGitStashPop.Lock()
	mock.calls.GitStashPop = append(mock.calls.GitStashPop, callInfo)
	lockGitGetRepoIMockGitStashPop.Unlock()
	mock.GitStashPopFunc()
}

// GitStashPopCalls gets all the calls that were made to GitStashPop.
// Check the length with:
//     len(mockedGitGetRepoI.GitStashPopCalls())
func (mock *GitGetRepoIMock) GitStashPopCalls() []struct {
} {
	var calls []struct {
	}
	lockGitGetRepoIMockGitStashPop.RLock()
	calls = mock.calls.GitStashPop
	lockGitGetRepoIMockGitStashPop.RUnlock()
	return calls
}

// GitStashSave calls GitStashSaveFunc.
func (mock *GitGetRepoIMock) GitStashSave() {
	if mock.GitStashSaveFunc == nil {
		panic("GitGetRepoIMock.GitStashSaveFunc: method is nil but GitGetRepoI.GitStashSave was just called")
	}
	callInfo := struct {
	}{}
	lockGitGetRepoIMockGitStashSave.Lock()
	mock.calls.GitStashSave = append(mock.calls.GitStashSave, callInfo)
	lockGitGetRepoIMockGitStashSave.Unlock()
	mock.GitStashSaveFunc()
}

// GitStashSaveCalls gets all the calls that were made to GitStashSave.
// Check the length with:
//     len(mockedGitGetRepoI.GitStashSaveCalls())
func (mock *GitGetRepoIMock) GitStashSaveCalls() []struct {
} {
	var calls []struct {
	}
	lockGitGetRepoIMockGitStashSave.RLock()
	calls = mock.calls.GitStashSave
	lockGitGetRepoIMockGitStashSave.RUnlock()
	return calls
}

// IsClean calls IsCleanFunc.
func (mock *GitGetRepoIMock) IsClean() bool {
	if mock.IsCleanFunc == nil {
		panic("GitGetRepoIMock.IsCleanFunc: method is nil but GitGetRepoI.IsClean was just called")
	}
	callInfo := struct {
	}{}
	lockGitGetRepoIMockIsClean.Lock()
	mock.calls.IsClean = append(mock.calls.IsClean, callInfo)
	lockGitGetRepoIMockIsClean.Unlock()
	return mock.IsCleanFunc()
}

// IsCleanCalls gets all the calls that were made to IsClean.
// Check the length with:
//     len(mockedGitGetRepoI.IsCleanCalls())
func (mock *GitGetRepoIMock) IsCleanCalls() []struct {
} {
	var calls []struct {
	}
	lockGitGetRepoIMockIsClean.RLock()
	calls = mock.calls.IsClean
	lockGitGetRepoIMockIsClean.RUnlock()
	return calls
}

// IsCurrentBranchRef calls IsCurrentBranchRefFunc.
func (mock *GitGetRepoIMock) IsCurrentBranchRef() bool {
	if mock.IsCurrentBranchRefFunc == nil {
		panic("GitGetRepoIMock.IsCurrentBranchRefFunc: method is nil but GitGetRepoI.IsCurrentBranchRef was just called")
	}
	callInfo := struct {
	}{}
	lockGitGetRepoIMockIsCurrentBranchRef.Lock()
	mock.calls.IsCurrentBranchRef = append(mock.calls.IsCurrentBranchRef, callInfo)
	lockGitGetRepoIMockIsCurrentBranchRef.Unlock()
	return mock.IsCurrentBranchRefFunc()
}

// IsCurrentBranchRefCalls gets all the calls that were made to IsCurrentBranchRef.
// Check the length with:
//     len(mockedGitGetRepoI.IsCurrentBranchRefCalls())
func (mock *GitGetRepoIMock) IsCurrentBranchRefCalls() []struct {
} {
	var calls []struct {
	}
	lockGitGetRepoIMockIsCurrentBranchRef.RLock()
	calls = mock.calls.IsCurrentBranchRef
	lockGitGetRepoIMockIsCurrentBranchRef.RUnlock()
	return calls
}

// PathExists calls PathExistsFunc.
func (mock *GitGetRepoIMock) PathExists(path string) (bool, os.FileInfo) {
	if mock.PathExistsFunc == nil {
		panic("GitGetRepoIMock.PathExistsFunc: method is nil but GitGetRepoI.PathExists was just called")
	}
	callInfo := struct {
		Path string
	}{
		Path: path,
	}
	lockGitGetRepoIMockPathExists.Lock()
	mock.calls.PathExists = append(mock.calls.PathExists, callInfo)
	lockGitGetRepoIMockPathExists.Unlock()
	return mock.PathExistsFunc(path)
}

// PathExistsCalls gets all the calls that were made to PathExists.
// Check the length with:
//     len(mockedGitGetRepoI.PathExistsCalls())
func (mock *GitGetRepoIMock) PathExistsCalls() []struct {
	Path string
} {
	var calls []struct {
		Path string
	}
	lockGitGetRepoIMockPathExists.RLock()
	calls = mock.calls.PathExists
	lockGitGetRepoIMockPathExists.RUnlock()
	return calls
}

// Prepare calls PrepareFunc.
func (mock *GitGetRepoIMock) Prepare() {
	if mock.PrepareFunc == nil {
		panic("GitGetRepoIMock.PrepareFunc: method is nil but GitGetRepoI.Prepare was just called")
	}
	callInfo := struct {
	}{}
	lockGitGetRepoIMockPrepare.Lock()
	mock.calls.Prepare = append(mock.calls.Prepare, callInfo)
	lockGitGetRepoIMockPrepare.Unlock()
	mock.PrepareFunc()
}

// PrepareCalls gets all the calls that were made to Prepare.
// Check the length with:
//     len(mockedGitGetRepoI.PrepareCalls())
func (mock *GitGetRepoIMock) PrepareCalls() []struct {
} {
	var calls []struct {
	}
	lockGitGetRepoIMockPrepare.RLock()
	calls = mock.calls.Prepare
	lockGitGetRepoIMockPrepare.RUnlock()
	return calls
}

// ProcessRepoBasedOnCleaness calls ProcessRepoBasedOnCleanessFunc.
func (mock *GitGetRepoIMock) ProcessRepoBasedOnCleaness() {
	if mock.ProcessRepoBasedOnCleanessFunc == nil {
		panic("GitGetRepoIMock.ProcessRepoBasedOnCleanessFunc: method is nil but GitGetRepoI.ProcessRepoBasedOnCleaness was just called")
	}
	callInfo := struct {
	}{}
	lockGitGetRepoIMockProcessRepoBasedOnCleaness.Lock()
	mock.calls.ProcessRepoBasedOnCleaness = append(mock.calls.ProcessRepoBasedOnCleaness, callInfo)
	lockGitGetRepoIMockProcessRepoBasedOnCleaness.Unlock()
	mock.ProcessRepoBasedOnCleanessFunc()
}

// ProcessRepoBasedOnCleanessCalls gets all the calls that were made to ProcessRepoBasedOnCleaness.
// Check the length with:
//     len(mockedGitGetRepoI.ProcessRepoBasedOnCleanessCalls())
func (mock *GitGetRepoIMock) ProcessRepoBasedOnCleanessCalls() []struct {
} {
	var calls []struct {
	}
	lockGitGetRepoIMockProcessRepoBasedOnCleaness.RLock()
	calls = mock.calls.ProcessRepoBasedOnCleaness
	lockGitGetRepoIMockProcessRepoBasedOnCleaness.RUnlock()
	return calls
}

// ProcessRepoBasedOnCurrentBranch calls ProcessRepoBasedOnCurrentBranchFunc.
func (mock *GitGetRepoIMock) ProcessRepoBasedOnCurrentBranch() {
	if mock.ProcessRepoBasedOnCurrentBranchFunc == nil {
		panic("GitGetRepoIMock.ProcessRepoBasedOnCurrentBranchFunc: method is nil but GitGetRepoI.ProcessRepoBasedOnCurrentBranch was just called")
	}
	callInfo := struct {
	}{}
	lockGitGetRepoIMockProcessRepoBasedOnCurrentBranch.Lock()
	mock.calls.ProcessRepoBasedOnCurrentBranch = append(mock.calls.ProcessRepoBasedOnCurrentBranch, callInfo)
	lockGitGetRepoIMockProcessRepoBasedOnCurrentBranch.Unlock()
	mock.ProcessRepoBasedOnCurrentBranchFunc()
}

// ProcessRepoBasedOnCurrentBranchCalls gets all the calls that were made to ProcessRepoBasedOnCurrentBranch.
// Check the length with:
//     len(mockedGitGetRepoI.ProcessRepoBasedOnCurrentBranchCalls())
func (mock *GitGetRepoIMock) ProcessRepoBasedOnCurrentBranchCalls() []struct {
} {
	var calls []struct {
	}
	lockGitGetRepoIMockProcessRepoBasedOnCurrentBranch.RLock()
	calls = mock.calls.ProcessRepoBasedOnCurrentBranch
	lockGitGetRepoIMockProcessRepoBasedOnCurrentBranch.RUnlock()
	return calls
}

// ProcessSymlinks calls ProcessSymlinksFunc.
func (mock *GitGetRepoIMock) ProcessSymlinks() {
	if mock.ProcessSymlinksFunc == nil {
		panic("GitGetRepoIMock.ProcessSymlinksFunc: method is nil but GitGetRepoI.ProcessSymlinks was just called")
	}
	callInfo := struct {
	}{}
	lockGitGetRepoIMockProcessSymlinks.Lock()
	mock.calls.ProcessSymlinks = append(mock.calls.ProcessSymlinks, callInfo)
	lockGitGetRepoIMockProcessSymlinks.Unlock()
	mock.ProcessSymlinksFunc()
}

// ProcessSymlinksCalls gets all the calls that were made to ProcessSymlinks.
// Check the length with:
//     len(mockedGitGetRepoI.ProcessSymlinksCalls())
func (mock *GitGetRepoIMock) ProcessSymlinksCalls() []struct {
} {
	var calls []struct {
	}
	lockGitGetRepoIMockProcessSymlinks.RLock()
	calls = mock.calls.ProcessSymlinks
	lockGitGetRepoIMockProcessSymlinks.RUnlock()
	return calls
}

// RepoPathExists calls RepoPathExistsFunc.
func (mock *GitGetRepoIMock) RepoPathExists() bool {
	if mock.RepoPathExistsFunc == nil {
		panic("GitGetRepoIMock.RepoPathExistsFunc: method is nil but GitGetRepoI.RepoPathExists was just called")
	}
	callInfo := struct {
	}{}
	lockGitGetRepoIMockRepoPathExists.Lock()
	mock.calls.RepoPathExists = append(mock.calls.RepoPathExists, callInfo)
	lockGitGetRepoIMockRepoPathExists.Unlock()
	return mock.RepoPathExistsFunc()
}

// RepoPathExistsCalls gets all the calls that were made to RepoPathExists.
// Check the length with:
//     len(mockedGitGetRepoI.RepoPathExistsCalls())
func (mock *GitGetRepoIMock) RepoPathExistsCalls() []struct {
} {
	var calls []struct {
	}
	lockGitGetRepoIMockRepoPathExists.RLock()
	calls = mock.calls.RepoPathExists
	lockGitGetRepoIMockRepoPathExists.RUnlock()
	return calls
}

// SetDefaultRef calls SetDefaultRefFunc.
func (mock *GitGetRepoIMock) SetDefaultRef() {
	if mock.SetDefaultRefFunc == nil {
		panic("GitGetRepoIMock.SetDefaultRefFunc: method is nil but GitGetRepoI.SetDefaultRef was just called")
	}
	callInfo := struct {
	}{}
	lockGitGetRepoIMockSetDefaultRef.Lock()
	mock.calls.SetDefaultRef = append(mock.calls.SetDefaultRef, callInfo)
	lockGitGetRepoIMockSetDefaultRef.Unlock()
	mock.SetDefaultRefFunc()
}

// SetDefaultRefCalls gets all the calls that were made to SetDefaultRef.
// Check the length with:
//     len(mockedGitGetRepoI.SetDefaultRefCalls())
func (mock *GitGetRepoIMock) SetDefaultRefCalls() []struct {
} {
	var calls []struct {
	}
	lockGitGetRepoIMockSetDefaultRef.RLock()
	calls = mock.calls.SetDefaultRef
	lockGitGetRepoIMockSetDefaultRef.RUnlock()
	return calls
}

// SetRepoFullPath calls SetRepoFullPathFunc.
func (mock *GitGetRepoIMock) SetRepoFullPath() {
	if mock.SetRepoFullPathFunc == nil {
		panic("GitGetRepoIMock.SetRepoFullPathFunc: method is nil but GitGetRepoI.SetRepoFullPath was just called")
	}
	callInfo := struct {
	}{}
	lockGitGetRepoIMockSetRepoFullPath.Lock()
	mock.calls.SetRepoFullPath = append(mock.calls.SetRepoFullPath, callInfo)
	lockGitGetRepoIMockSetRepoFullPath.Unlock()
	mock.SetRepoFullPathFunc()
}

// SetRepoFullPathCalls gets all the calls that were made to SetRepoFullPath.
// Check the length with:
//     len(mockedGitGetRepoI.SetRepoFullPathCalls())
func (mock *GitGetRepoIMock) SetRepoFullPathCalls() []struct {
} {
	var calls []struct {
	}
	lockGitGetRepoIMockSetRepoFullPath.RLock()
	calls = mock.calls.SetRepoFullPath
	lockGitGetRepoIMockSetRepoFullPath.RUnlock()
	return calls
}

// SetRepoLocalName calls SetRepoLocalNameFunc.
func (mock *GitGetRepoIMock) SetRepoLocalName() {
	if mock.SetRepoLocalNameFunc == nil {
		panic("GitGetRepoIMock.SetRepoLocalNameFunc: method is nil but GitGetRepoI.SetRepoLocalName was just called")
	}
	callInfo := struct {
	}{}
	lockGitGetRepoIMockSetRepoLocalName.Lock()
	mock.calls.SetRepoLocalName = append(mock.calls.SetRepoLocalName, callInfo)
	lockGitGetRepoIMockSetRepoLocalName.Unlock()
	mock.SetRepoLocalNameFunc()
}

// SetRepoLocalNameCalls gets all the calls that were made to SetRepoLocalName.
// Check the length with:
//     len(mockedGitGetRepoI.SetRepoLocalNameCalls())
func (mock *GitGetRepoIMock) SetRepoLocalNameCalls() []struct {
} {
	var calls []struct {
	}
	lockGitGetRepoIMockSetRepoLocalName.RLock()
	calls = mock.calls.SetRepoLocalName
	lockGitGetRepoIMockSetRepoLocalName.RUnlock()
	return calls
}

// SetSha calls SetShaFunc.
func (mock *GitGetRepoIMock) SetSha() {
	if mock.SetShaFunc == nil {
		panic("GitGetRepoIMock.SetShaFunc: method is nil but GitGetRepoI.SetSha was just called")
	}
	callInfo := struct {
	}{}
	lockGitGetRepoIMockSetSha.Lock()
	mock.calls.SetSha = append(mock.calls.SetSha, callInfo)
	lockGitGetRepoIMockSetSha.Unlock()
	mock.SetShaFunc()
}

// SetShaCalls gets all the calls that were made to SetSha.
// Check the length with:
//     len(mockedGitGetRepoI.SetShaCalls())
func (mock *GitGetRepoIMock) SetShaCalls() []struct {
} {
	var calls []struct {
	}
	lockGitGetRepoIMockSetSha.RLock()
	calls = mock.calls.SetSha
	lockGitGetRepoIMockSetSha.RUnlock()
	return calls
}
