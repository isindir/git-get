// Code generated by mockery v2.42.0. DO NOT EDIT.

package mocks

import (
	fs "io/fs"

	git "github.com/go-git/go-git/v5"

	mock "github.com/stretchr/testify/mock"
)

// RepoI is an autogenerated mock type for the RepoI type
type RepoI struct {
	mock.Mock
}

// ChoosePathPrefix provides a mock function with given fields: pathPrefix
func (_m *RepoI) ChoosePathPrefix(pathPrefix string) string {
	ret := _m.Called(pathPrefix)

	if len(ret) == 0 {
		panic("no return value specified for ChoosePathPrefix")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(pathPrefix)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Clone provides a mock function with given fields:
func (_m *RepoI) Clone() bool {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Clone")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// CreateSymlink provides a mock function with given fields: symlink
func (_m *RepoI) CreateSymlink(symlink string) {
	_m.Called(symlink)
}

// EnsurePathExists provides a mock function with given fields:
func (_m *RepoI) EnsurePathExists() {
	_m.Called()
}

// GetCurrentBranch provides a mock function with given fields:
func (_m *RepoI) GetCurrentBranch() string {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetCurrentBranch")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// GetRepoLocalName provides a mock function with given fields:
func (_m *RepoI) GetRepoLocalName() string {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetRepoLocalName")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// GitCheckout provides a mock function with given fields: branch
func (_m *RepoI) GitCheckout(branch string) bool {
	ret := _m.Called(branch)

	if len(ret) == 0 {
		panic("no return value specified for GitCheckout")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(branch)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// GitPull provides a mock function with given fields:
func (_m *RepoI) GitPull() {
	_m.Called()
}

// GitStashPop provides a mock function with given fields:
func (_m *RepoI) GitStashPop() bool {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GitStashPop")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// GitStashSave provides a mock function with given fields:
func (_m *RepoI) GitStashSave() bool {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GitStashSave")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// IsClean provides a mock function with given fields:
func (_m *RepoI) IsClean() bool {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for IsClean")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// IsCurrentBranchRef provides a mock function with given fields:
func (_m *RepoI) IsCurrentBranchRef() bool {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for IsCurrentBranchRef")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// IsRefBranch provides a mock function with given fields:
func (_m *RepoI) IsRefBranch() bool {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for IsRefBranch")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// IsRefTag provides a mock function with given fields:
func (_m *RepoI) IsRefTag() bool {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for IsRefTag")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// PathExists provides a mock function with given fields: path
func (_m *RepoI) PathExists(path string) (bool, fs.FileInfo) {
	ret := _m.Called(path)

	if len(ret) == 0 {
		panic("no return value specified for PathExists")
	}

	var r0 bool
	var r1 fs.FileInfo
	if rf, ok := ret.Get(0).(func(string) (bool, fs.FileInfo)); ok {
		return rf(path)
	}
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(path)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string) fs.FileInfo); ok {
		r1 = rf(path)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(fs.FileInfo)
		}
	}

	return r0, r1
}

// PlainOpen provides a mock function with given fields:
func (_m *RepoI) PlainOpen() (*git.Repository, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for PlainOpen")
	}

	var r0 *git.Repository
	var r1 error
	if rf, ok := ret.Get(0).(func() (*git.Repository, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() *git.Repository); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*git.Repository)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PrepareForGet provides a mock function with given fields:
func (_m *RepoI) PrepareForGet() {
	_m.Called()
}

// PrepareForMirror provides a mock function with given fields: pathPrefix, mirrorRootURL
func (_m *RepoI) PrepareForMirror(pathPrefix string, mirrorRootURL string) {
	_m.Called(pathPrefix, mirrorRootURL)
}

// ProcessRepoBasedOnCleaness provides a mock function with given fields:
func (_m *RepoI) ProcessRepoBasedOnCleaness() {
	_m.Called()
}

// ProcessRepoBasedOnCurrentBranch provides a mock function with given fields:
func (_m *RepoI) ProcessRepoBasedOnCurrentBranch() {
	_m.Called()
}

// ProcessSymlinks provides a mock function with given fields:
func (_m *RepoI) ProcessSymlinks() {
	_m.Called()
}

// RepoPathExists provides a mock function with given fields:
func (_m *RepoI) RepoPathExists() bool {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for RepoPathExists")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// SetDefaultRef provides a mock function with given fields:
func (_m *RepoI) SetDefaultRef() {
	_m.Called()
}

// SetRepoFullPath provides a mock function with given fields:
func (_m *RepoI) SetRepoFullPath() {
	_m.Called()
}

// SetRepoLocalName provides a mock function with given fields:
func (_m *RepoI) SetRepoLocalName() {
	_m.Called()
}

// SetSha provides a mock function with given fields:
func (_m *RepoI) SetSha() {
	_m.Called()
}

// NewRepoI creates a new instance of RepoI. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewRepoI(t interface {
	mock.TestingT
	Cleanup(func())
}) *RepoI {
	mock := &RepoI{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
